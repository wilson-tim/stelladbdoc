<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=Cp1252" />
<script src="P_STANDARD_LOGGING/report.js" type="text/javascript"></script>
<link href="P_STANDARD_LOGGING/report.css" type="text/css" rel="stylesheet">
</head>
<body>
<div class="banner">
<table width="98%"><tr>
<td><h2 class="banner">P_STANDARD_LOGGING</h2></td>
</tr></table></div>
<div id="maintabs">
<div class="currentmaintab" onclick="onSelectMainTab(this, 0)">
<div>
<p>Doc</p>
</div>
</div>
<div class="maintab" onclick="onSelectMainTab(this, 1)">
<div>
<p>Details</p>
</div>
</div>
<div class="maintab" onclick="onSelectMainTab(this, 2)">
<div>
<p>Grants</p>
</div>
</div>
<div class="maintab" onclick="onSelectMainTab(this, 3)">
<div>
<p>References</p>
</div>
</div>
<div class="maintab" onclick="onSelectMainTab(this, 4)">
<div>
<p>Dependencies</p>
</div>
</div>
<div class="maintab" onclick="onSelectMainTab(this, 5)">
<div>
<p>Code</p>
</div>
</div>
</div>
<br/>
<div id="masterreports">
<div id="Master.0">
<div class="currentmasterreport">
<TABLE CELLSPACING="0" CELLPADDING="1" WIDTH="100%" BORDER="0">
<TR><TD CLASS="NavBarRow3" VALIGN="top"><FONT SIZE="-2">      SUMMARY:  <A HREF="#field_summary">FIELD</A> | <A HREF="#type_summary">TYPE</A> | <A HREF="#method_summary">METHOD</A></FONT></TD><TD CLASS="NavBarRow3" VALIGN="top"><FONT SIZE="-2"></TR></TABLE><HR><P> Declare Global Variables</P><HR><TABLE CELLSPACING="0" CELLPADDING="1" WIDTH="100%" BORDER="0">
<TR><TD CLASS="NavBarRow3" VALIGN="top"><FONT SIZE="-2">      SUMMARY:  <A HREF="#field_summary">FIELD</A> | <A HREF="#type_summary">TYPE</A> | <A HREF="#method_summary">METHOD</A></FONT></TD><TD CLASS="NavBarRow3" VALIGN="top"><FONT SIZE="-2"></TR></TABLE></div>
</div>
<div id="Master.1">
<div class="masterreport">
<table id="Table.0" cellpadding="0" cellspacing="0" summary="">
<th>NAME</th>
<th>VALUE</th>
</tr>
<tr>
<td>OWNER</td>
<td>STELLA</td>
</tr>
<tr>
<td>OBJECT_NAME</td>
<td>P_STANDARD_LOGGING</td>
</tr>
<tr>
<td>SUBOBJECT_NAME</td>
<td>null</td>
</tr>
<tr>
<td>OBJECT_ID</td>
<td>3625235</td>
</tr>
<tr>
<td>DATA_OBJECT_ID</td>
<td>null</td>
</tr>
<tr>
<td>OBJECT_TYPE</td>
<td>PACKAGE&nbsp;BODY</td>
</tr>
<tr>
<td>CREATED</td>
<td>08-JAN-20</td>
</tr>
<tr>
<td>LAST_DDL_TIME</td>
<td>09-JAN-20</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>2020-01-09:10:45:07</td>
</tr>
<tr>
<td>STATUS</td>
<td>VALID</td>
</tr>
<tr>
<td>TEMPORARY</td>
<td>N</td>
</tr>
<tr>
<td>GENERATED</td>
<td>N</td>
</tr>
<tr>
<td>SECONDARY</td>
<td>N</td>
</tr>
<tr>
<td>NAMESPACE</td>
<td>2</td>
</tr>
<tr>
<td>EDITION_NAME</td>
<td>null</td>
</tr>
</table>
</div>
</div>
<div id="Master.2">
<div class="masterreport">
<table id="Table.1" cellpadding="0" cellspacing="0" summary="">
<tr>
<th>PRIVILEGE</th>
<th>GRANTEE</th>
<th>GRANTABLE</th>
<th>GRANTOR</th>
<th>OBJECT_NAME</th>
</tr>
</table>
</div>
</div>
<div id="Master.3">
<div class="masterreport">
<table id="Table.2" cellpadding="0" cellspacing="0" summary="">
<tr>
<th>NAME</th>
<th>OWNER</th>
<th>TYPE</th>
<th>OBJECT_ID</th>
<th>STATUS</th>
<th>TYPE_LINK</th>
</tr>
</table>
</div>
</div>
<div id="Master.4">
<div class="masterreport">
<table id="Table.3" cellpadding="0" cellspacing="0" summary="">
<tr>
<th>NAME</th>
<th>OWNER</th>
<th>TYPE</th>
<th>OBJECT_ID</th>
<th>STATUS</th>
<th>TYPE_LINK</th>
</tr>
</table>
</div>
</div>
<div id="Master.5">
<div class="masterreport">
<pre>
PACKAGE BODY          "P_STANDARD_LOGGING" IS

  -- Declare Global Variables
  g_new_line             CONSTANT VARCHAR2(2) := chr(10);

  g_LoggingApplication   VARCHAR2(8)          := NULL;
  g_LoggingProcedureName VARCHAR2(100)        := NULL;
  g_PipeName             VARCHAR2(100)        := NULL;
  g_FileName             VARCHAR2(100)        := NULL;
  g_FullFileName         VARCHAR2(100)        := NULL;
  g_LoggingDir           VARCHAR2(100)        := NULL;

  g_IntervalPeriod       INTEGER(10)          := NULL;
  g_AppLoggingLevel      INTEGER(10)          := NULL;

  g_LoggingChecked       BOOLEAN              := FALSE;
  g_LoggingRequired      BOOLEAN              := FALSE;

  g_LoggingLastCheck     DATE                 := NULL;

  g_LoggingFile          utl_file.file_type;


   g_version             VARCHAR2(10)         := '1.00';


  /*
  ***************************************************************************************
  * Get_Version                                                                         *
  *                                                                                     *
  * This function will return the current version of the package set as a global        *
  * variable.                                                                           *
  *                                                                                     *
  * Example Call                                                                        *
  *  v_Version := Get_Version;                                                          *
  ***************************************************************************************
  */
  FUNCTION Get_Version RETURN VARCHAR2 IS
  BEGIN
    RETURN(g_version);
  END Get_Version;



  /*
  ***************************************************************************************
  * Get_Registry_Property                                                               *
  *                                                                                     *
  * Have created a package specific version of this function (original in App_Util)     *
  * to prevent raising an application error if registry table not set up correctly,     *
  * This version will just retrun a NULL value so default standard values can be used   *
  *                                                                                     *
  * Example Call                                                                        *
  *  v_Parameter := Get_Registry_Property('TESTAPP','ALL','ALL','TestParameter');       *
  ***************************************************************************************
  */
  FUNCTION Get_Registry_Property (p_Application  IN  application.application_key%TYPE,
                                  p_AppMode      IN  application_registry.application_mode%TYPE,
                                  p_UserKey      IN  application_registry.user_key%TYPE,
                                  p_ParamKey     IN  application_registry.parameter_key%TYPE)                                      
  RETURN application_registry.parameter_value%TYPE IS

    v_return                      application_registry.parameter_value%TYPE;
    registry_error                EXCEPTION;
    PRAGMA EXCEPTION_INIT(registry_error, -20000);

  BEGIN

    BEGIN
      -- Make call to original function in app_util
      v_return := app_util.get_registry_property(p_Application,p_AppMode,p_UserKey,p_ParamKey);

      -- If error returned from app_util then just set returning value to null
      EXCEPTION 
      WHEN registry_error THEN
        v_return := NULL;
    END;

    RETURN (v_return);

  END Get_Registry_Property;



  /*
  ***************************************************************************************
  * Set_Pipe_Global                                                                     *
  *                                                                                     *
  * This procedure sets all the pipe variables from the application_registry table      *
  * into global variables for use by other procedures and functions within the package. *
  * Current variables set are Pipe Name, Interval Period, Filename Prefix and Logging   *
  * Directory                                                                           *
  *                                                                                     *
  * Example Call                                                                        *
  *  Set_Pipe_Global('TESTAPP');                                                        *
  ***************************************************************************************
  */
  PROCEDURE Set_Pipe_Global (p_Application  IN  application.application_key%TYPE) IS

  BEGIN
    -- Get Interval Refresh Period (in seconds)      
    g_IntervalPeriod    := To_Number(Get_Registry_Property(p_Application,'ALL', 'ALL','IntervalPeriod'));      

    -- Get PipeName
    g_PipeName := Get_Registry_Property(p_Application,'ALL','ALL','PipeName');

    -- Get FileName
    g_FileName := Get_Registry_Property(p_Application,'ALL','ALL','FileName');
    g_FullFilename := g_FileName||to_char(SYSDATE,'ddmmyyyy')||'.debug';

    -- Get Logging Directory
    g_LoggingDir := Get_Registry_Property(p_Application,'ALL','ALL','LogDir');

  END Set_Pipe_Global;



  /*
  ***************************************************************************************
  * Set_Up_Logging                                                                      *
  *                                                                                     *
  * This procedure sets up the logging at an application and procedure level.  It is    *
  * not called directly but from the wrap around functions Init_Logging &               *
  * Recheck_Logging.                                                                    *
  * This procedure sets the Application Pipe Name, Logging Level as well as placing a   *
  * call to the Set_Pipe_Global procedure                                               *
  *                                                                                     *
  * Example Call                                                                        *
  *  None needed this is a Private function not called directly                         *
  ***************************************************************************************
  */
  PROCEDURE Set_Up_Logging (p_Application   IN  application.application_key%TYPE,
                            p_ProcedureName IN  VARCHAR2) IS

    v_LoggingReq          application_registry.parameter_value%TYPE;                            
    v_AppLoggingLevel     application_registry.parameter_value%TYPE;
    v_PipeApp             application_registry.parameter_value%TYPE;

  BEGIN
    -- Set date of last check (used in recheck procedure)
    g_LoggingLastCheck   := SYSDATE;

    -- Get all the parameters from the application_registry table and store as global variables
    v_LoggingReq         := Get_Registry_Property(p_Application,'ALL', 'ALL',p_ProcedureName||'PipeLogging');
    IF v_LoggingReq = 'Y' THEN 
      g_LoggingRequired  := TRUE;
    ELSE
      g_LoggingRequired := FALSE;
      g_AppLoggingLevel := NULL;
      g_IntervalPeriod  := NULL;
      g_PipeName        := NULL;
    END IF;

    IF g_LoggingRequired THEN  
      -- Get Logging Level from App and then transfer it into it's integer value
      v_AppLoggingLevel   := Get_Registry_Property(p_Application,'ALL', 'ALL',p_ProcedureName||'LogLevel');
      IF v_AppLoggingLevel IS NULL THEN 
        SELECT dl.log_value
        INTO g_AppLoggingLevel
        FROM debug_level dl
        WHERE dl.log_level = 'FATAL';
      ELSE  
        SELECT dl.log_value
        INTO g_AppLoggingLevel
        FROM debug_level dl
        WHERE dl.log_level = Upper(v_AppLoggingLevel);
      END IF;

      -- Get Name of Pipe
      v_PipeApp  := Get_Registry_Property(p_Application,'ALL','ALL',p_ProcedureName||'PipeApp');

      -- Set up Pipe related variables as global variables
      Set_Pipe_Global (v_PipeApp);
    END IF;  
  END Set_Up_Logging;



  /*
  ***************************************************************************************
  * Init_Logging                                                                        *
  *                                                                                     *
  * This procedure is called once from the procedure wishing to use the logging         *
  * procedures.  It would be the initial call before any logging takes place            *
  * All this procedure does is place a call to the private procedure Set_Up_Logging     *
  *                                                                                     *
  * Example Call                                                                        *
  *  Init_Logging('TESTAPP','TestProc');                                                *
  ***************************************************************************************
  */
  PROCEDURE Init_Logging (p_Application   IN  application.application_key%TYPE,
                          p_ProcedureName IN  VARCHAR2) IS
  BEGIN
    g_LoggingApplication   := p_Application;
    g_LoggingProcedureName := p_ProcedureName;

    IF g_LoggingChecked = FALSE THEN  
      -- Now make the call to set up the logging
      Set_Up_Logging (p_Application,
                      p_ProcedureName);
    END IF;                  
  END Init_Logging;


  /*
  ***************************************************************************************
  * Time_Passed                                                                         *
  *                                                                                     *
  * This function returns a boolean value as to whether the interval period (from the   *
  * application_registry and set in the Set_Pipe_Global procedure) has passed since the *
  * last check                                                                          *
  *                                                                                     *
  * Example Call                                                                        *
  * If Time_Passed Then                                                                 *
  *   Do_Something;                                                                     *
  * End If;                                                                             *
  ***************************************************************************************
  */  
  FUNCTION Time_Passed RETURN BOOLEAN IS
  BEGIN

    -- See if interval period (in seconds) has passed since the last check
    IF (g_LoggingLastCheck + (g_IntervalPeriod / (24 * 60 * 60)) &lt; SYSDATE) THEN
      RETURN TRUE;
    ELSE 
      RETURN FALSE;
    END IF;  
  END Time_Passed;



  /*
  ***************************************************************************************
  * Time_Passed                                                                         *
  *                                                                                     *
  * This procedure will recheck whether the logging has been switched off, it is called *
  * from Output_Log_Message and checks that the interval period has passed before       *
  * calling the Set_Up_Logging procedure (which will see if logging at the application  *
  * level has been switched off                                                         *
  *                                                                                     *
  * Example Call                                                                        *
  * None required as private procedure                                                  *
  ***************************************************************************************
  */
  PROCEDURE Recheck_Logging IS
  BEGIN

    -- Need to check whether the interval period has passed and if so make call to 
    -- set up the logging again
    IF Time_Passed THEN
      Set_Up_Logging (g_LoggingApplication,
                      g_LoggingProcedureName);
    END IF;                  
  END Recheck_Logging;



  /*
  ***************************************************************************************
  * Output_Log_Message                                                                  *
  *                                                                                     *
  * This is the main procedure which outputs the log message.  It is only necessary to  *
  * pass in the message and logging level as the Init_Logging procedure will have stored*
  * all the other details as global variables.  This procedure can be used to send a    *
  * message to the console also as long as p_common.Set_Debug_Mode('ON') has already    *
  * been called.  If the level of the message is higher than the set level then the     *
  * message will not be sent to the pipe (but will still go to the console if set).     *
  * The level can be set by using the public constants declared in the header of this   *
  * package.                                                                            *
  *           p_Standard_Logging.g_DebugLevel                                           *
  *           p_Standard_Logging.g_InfoLevel                                            *
  *           p_Standard_Logging.g_WarningLevel                                         *
  *           p_Standard_Logging.g_ErrorLevel                                           *
  *           p_Standard_Logging.g_FatalLevel                                           *
  *                                                                                     *
  * If Debug Level is set then all messages will be sent to the pipe but if warning     *
  * level is set then only messages with a level of warning, error or Fatal will be     *
  * sent                                                                                *
  *                                                                                     *
  * Example Call                                                                        *
  * Output_Log_Message('This is a test message',p_Standard_Logging.g_DebugLevel);       *
  ***************************************************************************************
  */
  PROCEDURE Output_Log_Message (p_Message       IN  VARCHAR2,
                                p_Level         IN  INTEGER DEFAULT 50) IS

    v_MessageOut        VARCHAR2(32000);
    v_Status            INTEGER(10);
    v_LevelDesc         VARCHAR2(100);

  BEGIN

    -- Check to see if application needs to have message output at this level    
    IF g_AppLoggingLevel &lt;= p_Level THEN

      -- Logging to the pipe is switched on
      IF g_LoggingRequired THEN

        -- Get a description of the level from the Debug_Level table
        SELECT dl.log_level
        INTO v_LevelDesc
        FROM Debug_Level dl
        WHERE dl.log_value = (SELECT MIN(dl2.log_value)
                              FROM Debug_Level dl2
                              WHERE dl2.log_value >= p_Level
                             );

        -- Make the message include the Application, Time Stamp and Level Description as well as the
        -- message sent
        v_MessageOut := g_LoggingApplication||','||to_char(SYSDATE,'dd/mm/yyyy HH24:MI:SS')||','||v_LevelDesc||','||p_Message;

        -- Actually pack and send message to the pipe
        DBMS_PIPE.pack_message(v_MessageOut);    
        v_status := DBMS_PIPE.send_message(g_PipeName);

        -- If message has not been sent successfully we don't want to cause main calling 
        -- prcoedure to fall over so all we can really do is send a message to the console and the message also
        IF v_status != 0 THEN
          p_common.debug_message('Unable to send message to pipe');
          p_common.Debug_Message(v_MessageOut); 
        END IF;

      END IF; 

      -- Check to see if time has passed and reget pipe settings if necessary
      Recheck_Logging;

    END IF;     

    -- If Console logging has been switched on the send to the console also (but only original message)
    IF p_common.debug_on = TRUE THEN
      p_common.debug_message(p_Message);
    END IF;        
  END Output_Log_Message;



  /*
  ***************************************************************************************
  * Clear_Pipe                                                                          *
  *                                                                                     *
  * This procedure will remove any queueing messages in the pipe, typically this would  *
  * be run once the pipe has been shut down                                             *
  *                                                                                     *
  * Example Call                                                                        *
  * Clear_Pipe('TESTAPP');                                                          *
  ***************************************************************************************
  */
  PROCEDURE Clear_Pipe (p_Application  IN  application.application_key%TYPE) IS

    v_PipeName         VARCHAR2(100);

  BEGIN
    -- Get Name of Pipe
    v_PipeName := Get_Registry_Property(p_Application,'ALL','ALL','PipeName');

    -- Clear down all waiting messages
    dbms_pipe.purge(v_PipeName);

  END Clear_Pipe;



  /*
  ***************************************************************************************
  * Start_Pipe                                                                          *
  *                                                                                     *
  * This procedure starts up the pipe.  The application passed into it is the high level* 
  * Pipe Applications that contains registry details about Pipe Name, File Name Interval* 
  * Period and Logging Directory.  If the pipe isn't started then messages sent using   *
  * Output_Log_Message (to the pipe) will start to build up until the pipe is either    *
  * started (at which point all the queued messages will come down) or the pipe is      *
  * purged.                                                                             *
  *                                                                                     *
  * Example Call                                                                        *
  * Start_Pipe('TESTAPP');                                                              *
  ***************************************************************************************
  */
  PROCEDURE Start_Pipe (p_Application  IN     application.application_key%TYPE) IS

    l_result          INTEGER;
    v_loc             VARCHAR2(10);



  BEGIN
    -- Ensure that the LoggingOn Parameter is set to Y as this is used to stop the pipe
    v_loc   := '001';
    BEGIN
      UPDATE Application_Registry ar
      SET    ar.parameter_value  = 'Y'
      WHERE  ar.application_key  = p_Application
      AND    ar.application_mode = 'ALL'
      AND    ar.user_key         = 'ALL'
      AND    ar.parameter_key    = 'LoggingOn';

      COMMIT;

      EXCEPTION
      WHEN OTHERS THEN
        p_common.handle_error('p_Standard_Logging.Start_Pipe',
                              v_loc,
                              '900',
                              'Unable to update parameter LoggingOn for '||p_Application);
    END;

    -- Set up the Global Pipe variables
    Set_Pipe_Global (p_Application);
    g_LoggingLastCheck := SYSDATE;

    -- Ensure that the file is there and start appending to it
    g_LoggingFile := utl_file.fopen(g_LoggingDir,g_FullFilename,'A');

    -- If there are elements missing from the application_registry table then raise an error
    IF (g_FileName IS NULL OR g_PipeName IS NULL OR g_LoggingDir IS NULL) THEN
      p_common.handle_error('p_Standard_Logging.Start_Pipe',
                            v_loc,
                            '900',
                            'Application table not set up correctly for '||p_Application);
    END IF;

    -- Create the pipe
    v_loc := '002';
    l_result := DBMS_PIPE.create_pipe(pipename => g_PipeName,
                                      private  => FALSE);

    -- Raise an error if pipe creation not successful
    IF l_result != 0 THEN
      p_common.handle_error('p_Standard_Logging.Start_Pipe',
                            v_loc,
                            SQLCODE,
                            'Unable to start pipe for '||p_Application);
    ELSE

      -- Add a log entry stating what time the pipe was switched on    
      utl_file.put_line(g_LoggingFile,
                       'DEBUG logging started at: '
                       ||to_char(SYSDATE,'DD/MM/YYYY HH24:MI:SS')
                       );
      utl_file.fflush(g_LoggingFile);                  

    END IF;                                                                            
  END Start_Pipe;



  /*
  ***************************************************************************************
  * Stop_Pipe                                                                           *
  *                                                                                     *
  * This procedure switches the logging off for the pipe (detailed in high level        *
  * application passed in).  The Unpack_Message procedure continually polls for this    *
  * flag and will stop when it finds that it has been set to an 'N'                     *
  *                                                                                     *
  * Example Call                                                                        *
  * Stop_Pipe('TESTAPP');                                                               *
  ***************************************************************************************
  */
  PROCEDURE Stop_Pipe (p_Application  IN  application.application_key%TYPE,
                       p_Purge        IN  VARCHAR2) IS

    v_loc         VARCHAR2(10);

  BEGIN
    v_loc := '001';    
    -- Set the LoggingOn parameter to 'N'
    -- Actual Pipe will be stopped by the Unpack Message procedure
    BEGIN
      UPDATE Application_Registry ar
      SET    ar.parameter_value  = 'N'
      WHERE  ar.application_key  = p_Application
      AND    ar.application_mode = 'ALL'
      AND    ar.user_key         = 'ALL'
      AND    ar.parameter_key    = 'LoggingOn';

      COMMIT;

      EXCEPTION
      WHEN OTHERS THEN
        p_common.handle_error('p_Standard_Logging.Start_Pipe',
                              v_loc,
                              '900',
                              'Unable to update parameter LoggingOn for '||p_Application);
    END;

    IF p_Purge = 'Y' THEN
      Clear_Pipe (p_Application);
    END IF;  
  END Stop_Pipe;



  /*
  ***************************************************************************************
  * Check_Pipe_SetUp                                                                    *
  *                                                                                     *
  * This procedure will check the application_registry table has been set up correctly  *
  * for the application passed in.  The application passed in will be assumed to be a   *
  * Pipe Application                                                                    *
  * The output of this procedure is sent to the console                                 *
  *                                                                                     *
  * Example Call                                                                        *
  * Check_Pipe_SEtUp('TESTAPP');                                                        *
  ***************************************************************************************
  */
  PROCEDURE Check_Pipe_SetUp (p_Application  IN  application.application_key%TYPE) IS


    -- Private Procedure to perform checks and output error message
    PROCEDURE Check_Parameter (p_AppName    IN     application.application_key%TYPE,
                               p_ParamName  IN     application_registry.parameter_key%TYPE) IS

      v_Check            application_registry.parameter_value%TYPE;
      v_Count            INTEGER;
      v_Message          VARCHAR2(512);

    BEGIN

      v_Check := Get_Registry_Property(p_AppName,'ALL','ALL',p_ParamName);

      IF v_Check IS NULL THEN
        v_Message := 'Parameter '''||p_ParamName||''' not set up correctly ';
      ELSE
        v_Message := 'Parameter '''||p_ParamName||''' has value '||v_Check;        

        -- Check that Logging Directory specified in application_registry actually exists
        IF p_ParamName = 'LogDir' THEN
          BEGIN
            SELECT COUNT(*) 
            INTO v_count
            FROM All_Objects ao
            WHERE ao.object_type = 'DIRECTORY'
            AND TRIM(ao.object_name) = TRIM(v_Check);

            EXCEPTION
            WHEN no_data_found THEN
              v_count := 0;
          END;    

          IF v_count = 0 THEN
            v_Message := v_Message||g_new_line||
                         'Directory Object '''||v_Check||''' does not exist';            
          END IF;

        END IF;
      END IF;
      -- Output Success or Fail message
      p_common.debug_message(v_Message);

    END Check_Parameter;

  BEGIN

    -- Switch on debug mode
    p_common.Set_Debug_Mode('ON'); 

    -- Check all parameters are set up
    Check_Parameter(p_Application,
                    'PipeName');

    Check_Parameter(p_Application,
                    'FileName');

    Check_Parameter(p_Application,
                    'LogDir');

    Check_Parameter(p_Application,
                    'IntervalPeriod');

    Check_Parameter(p_Application,
                    'LoggingOn');

    Check_Parameter(p_Application,
                    'HoldLogsFor');

  END Check_Pipe_SetUp;


  /*
  ***************************************************************************************
  * Check_Application_SetUp                                                             *
  *                                                                                     *
  * This procedure will check the application_registry table has been set up correctly  *
  * for the application passed in in order for it to be able to use the standard pipe   *
  * logging procedures.                                                                 *
  * The output of this procedure is sent to the console                                 *
  *                                                                                     *
  * Example Call                                                                        *
  * Check_Pipe_SetUp('TESTAPP','TestProc');                                                        *
  ***************************************************************************************
  */
  PROCEDURE Check_Application_SetUp (p_Application   IN  application.application_key%TYPE,
                                     p_ProcedureName IN  VARCHAR2) IS

    -- Private Procedure to perform checks and build error message
    PROCEDURE Check_Parameter (p_AppName    IN     application.application_key%TYPE,
                               p_ParamName  IN     application_registry.parameter_key%TYPE) IS

      v_Check            application_registry.parameter_value%TYPE;
      v_Message          VARCHAR2(512);

    BEGIN

      v_Check := Get_Registry_Property(p_AppName,'ALL','ALL',p_ParamName);

      IF v_Check IS NULL THEN
        v_Message := 'Parameter '''||p_ParamName||''' not set up correctly ';
      ELSE
        v_Message := 'Parameter '''||p_ParamName||''' has value '||v_Check;                
      END IF;

      p_common.debug_message(v_Message);

    END Check_Parameter;

  BEGIN

    -- Switch on debug mode
    p_common.Set_Debug_Mode('ON'); 

    -- Check all parameters are set up
    Check_Parameter(p_Application,
                    p_ProcedureName||'PipeLogging');

    Check_Parameter(p_Application,
                    p_ProcedureName||'LogLevel');

    Check_Parameter(p_Application,
                    p_ProcedureName||'PipeApp');


  END Check_Application_SetUp;



  /*
  ***************************************************************************************
  * Set_Up_New_Pipe                                                                     *
  *                                                                                     *
  * This procedure will set up the application and application_registry tables for a    *
  * new pipe.                                                                           *
  *                                                                                     *
  * Example Call                                                                        *
  * Set_Up_New_Pipe('TESTAPP','TestFile',300,'Test_Dir','TestPipe',10);                 *
  ***************************************************************************************
  */
  PROCEDURE Set_Up_New_Pipe (p_PipeApp        IN  application.application_key%TYPE,
                             p_FileName       IN  application_registry.parameter_value%TYPE,
                             p_IntervalPeriod IN  application_registry.parameter_value%TYPE,
                             p_LogDir         IN  application_registry.parameter_value%TYPE,
                             p_PipeName       IN  application_registry.parameter_value%TYPE,
                             p_HoldFor        IN  application_registry.parameter_value%TYPE) IS

  Primary_Key_Error                 EXCEPTION;
  PRAGMA EXCEPTION_INIT(primary_key_error, -00001);

  BEGIN

    -- Check to see if p_PipeApp already exists in application table and if not
    -- then create it
    BEGIN
      INSERT INTO Application
      (
      application_key,
      description,
      status_check_disabled_ind
      )
      VALUES
      (
      p_PipeApp,
      'Pipe for p_Standard_Logging',
      'N'
      );

      EXCEPTION
      WHEN Primary_Key_Error THEN
        -- Application Already set up so no need to do anything
        NULL;
    END;

    -- Now set up the application_registry
    BEGIN

      -- Set up File Name
      INSERT INTO application_registry
      (
      application_key,
      application_mode,
      user_key,
      parameter_key,
      parameter_type,
      parameter_value,
      description
      )
      VALUES
      (
      p_PipeApp,
      'ALL',
      'ALL',
      'FileName',
      'String',
      p_FileName,
      'Name of Pipe used for Logging'
      );

      EXCEPTION 
      WHEN Primary_Key_error THEN
        -- Application_Registry already set up so do nothing
        NULL;
    END;


    BEGIN

      -- Set up Interval Period
      INSERT INTO application_registry
      (
      application_key,
      application_mode,
      user_key,
      parameter_key,
      parameter_type,
      parameter_value,
      description
      )
      VALUES
      (
      p_PipeApp,
      'ALL',
      'ALL',
      'IntervalPeriod',
      'Integer',
      p_IntervalPeriod,
      'Interval Period in seconds between logging checks'
      );

      EXCEPTION 
      WHEN Primary_Key_error THEN
        -- Application_Registry already set up so do nothing
        NULL;
    END;

    BEGIN

      -- Set up Logging Directory
      INSERT INTO application_registry
      (
      application_key,
      application_mode,
      user_key,
      parameter_key,
      parameter_type,
      parameter_value,
      description
      )
      VALUES
      (
      p_PipeApp,
      'ALL',
      'ALL',
      'LogDir',
      'String',
      p_LogDir,
      'Name of Pipe used for Standard Logging'
      );

      EXCEPTION 
      WHEN Primary_Key_error THEN
        -- Application_Registry already set up so do nothing
        NULL;
    END;

    BEGIN

      -- Set up Pipe Name
      INSERT INTO application_registry
      (
      application_key,
      application_mode,
      user_key,
      parameter_key,
      parameter_type,
      parameter_value,
      description
      )
      VALUES
      (
      p_PipeApp,
      'ALL',
      'ALL',
      'PipeName',
      'String',
      p_PipeName,
      'Name of Pipe used for Standard Logging'
      );

      EXCEPTION 
      WHEN Primary_Key_error THEN
        -- Application_Registry already set up so do nothing
        NULL;
    END;

    BEGIN

      -- Set up Logging On parameter
      INSERT INTO application_registry
      (
      application_key,
      application_mode,
      user_key,
      parameter_key,
      parameter_type,
      parameter_value,
      description
      )
      VALUES
      (
      p_PipeApp,
      'ALL',
      'ALL',
      'LoggingOn',
      'String',
      'Y',
      'Y/N flag to switch logging off or on for this pipe'
      );

      EXCEPTION 
      WHEN Primary_Key_error THEN
        -- Application_Registry already set up so do nothing
        NULL;

    END;


    BEGIN

      -- Set up Hold Logs parameter
      INSERT INTO application_registry
      (
      application_key,
      application_mode,
      user_key,
      parameter_key,
      parameter_type,
      parameter_value,
      description
      )
      VALUES
      (
      p_PipeApp,
      'ALL',
      'ALL',
      'HoldLogsFor',
      'Integer',
      p_HoldFor,
      'Number of Days to keep the log files for'
      );

      EXCEPTION 
      WHEN Primary_Key_error THEN
        -- Application_Registry already set up so do nothing
        NULL;

    END;

    COMMIT;

  END Set_Up_New_Pipe;                             



  /*
  ***************************************************************************************
  * Set_Up_New_App                                                                      *
  *                                                                                     *
  * This procedure will set up the application_registry tables for an application and   *
  * procedure/function in order for it tobe able use the standard logging procedures    *
  *                                                                                     *
  * Example Call                                                                        *
  * Set_Up_New_App('TESTAPP','TestProc','TESTPIPE','DEBUG');                                                          *
  ***************************************************************************************
  */
  PROCEDURE Set_Up_New_App (p_App              IN  application.application_key%TYPE,
                            p_ProcedureName    IN  application_registry.parameter_value%TYPE,
                            p_PipeApp          IN  application.application_key%TYPE,
                            p_LoggingLevel     IN  application_registry.parameter_value%TYPE) IS

  Primary_Key_Error                 EXCEPTION;
  PRAGMA EXCEPTION_INIT(primary_key_error, -00001);

  v_count              INTEGER(10);

  BEGIN

    -- Check to see if p_PipeApp already exists in application table, if it doesn't
    -- then do nothing 
    BEGIN
      SELECT COUNT(*)
      INTO   v_count
      FROM   application app    
      WHERE  app.application_key = p_PipeApp;

      EXCEPTION
      WHEN no_data_found THEN
        v_count := 0;
    END;  

    IF v_count != 0 THEN
      -- Now set up the application_registry
      BEGIN

        -- Set up Logging Level
        INSERT INTO application_registry
        (
        application_key,
        application_mode,
        user_key,
        parameter_key,
        parameter_type,
        parameter_value,
        description
        )
        VALUES
        (
        p_App,
        'ALL',
        'ALL',
        p_ProcedureName||'LogLevel',
        'String',
        p_LoggingLevel,
        'Level of logging for procedure '||p_ProcedureName
        );

        EXCEPTION 
        WHEN Primary_Key_error THEN
          -- Application_Registry already set up so do nothing
          NULL;
      END;


      BEGIN

        -- Set up Pipe App
        INSERT INTO application_registry
        (
        application_key,
        application_mode,
        user_key,
        parameter_key,
        parameter_type,
        parameter_value,
        description
        )
        VALUES
        (
        p_App,
        'ALL',
        'ALL',
        p_ProcedureName||'PipeApp',
        'String',
        p_PipeApp,
        'Application name of pipe'
        );

        EXCEPTION 
        WHEN Primary_Key_error THEN
          -- Application_Registry already set up so do nothing
          NULL;
      END;

      BEGIN

        -- Set up Pipe Logging
        INSERT INTO application_registry
        (
        application_key,
        application_mode,
        user_key,
        parameter_key,
        parameter_type,
        parameter_value,
        description
        )
        VALUES
        (
        p_App,
        'ALL',
        'ALL',
        p_ProcedureName||'PipeLogging',
        'String',
        'Y',
        'Switch on/off logging for procedure '||p_ProcedureName
        );

        EXCEPTION 
        WHEN Primary_Key_error THEN
          -- Application_Registry already set up so do nothing
          NULL;
      END;

      COMMIT;
    ELSE 
      p_common.handle_error('p_Standard_Logging.Set_Up_New_App',
                            '001',
                            '900',
                            'Unable to Set Up '||p_App||'.'||p_ProcedureName||' as Pipe not set up');
    END IF;

  END Set_Up_New_App;                             



  /*
  ***************************************************************************************
  * Switch_Off_App_Logging                                                              *
  *                                                                                     *
  * This procedure will switch off logging for an application at procedure level by     *
  * setting the application_registry parameter PipeLogging to an 'N'.  This value will  *
  * be picked up by the rechecking procedures and stop sending messages to the pipe.    *
  *                                                                                     *
  * Example Call                                                                        *
  * Switch_Off_App_Logging('TESTAPP','TestProc');                                                  *
  ***************************************************************************************
  */
  PROCEDURE Switch_Off_App_Logging (p_Application    IN application.application_key%TYPE,
                                    p_ProcedureName  IN VARCHAR2) IS

    v_ParamKey          application_registry.parameter_key%TYPE;                                  

  BEGIN

    -- Build Parameter Key as a concatenation of Procedure Name + 'PipeLogging'
    v_ParamKey := TRIM(p_ProcedureName)||'PipeLogging';

    -- Update Application_Registry
    UPDATE application_registry ar
    SET    ar.parameter_value = 'N'
    WHERE  ar.application_key = p_Application
    AND    ar.application_mode = 'ALL'
    AND    ar.user_key = 'ALL'
    AND    ar.parameter_key = v_ParamKey;

    COMMIT;

    EXCEPTION
    WHEN OTHERS THEN
      p_common.handle_error('p_Standard_Logging.Switch_Off_App_Logging',
                            '001',
                            '900',
                            'Unable to switch Off Logging for '||p_Application||'.'||p_ProcedureName);

  END Switch_Off_App_Logging;



  /*
  ***************************************************************************************
  * Switch_On_App_Logging                                                               *
  *                                                                                     *
  * This procedure will switch on logging for an application at procedure level by      *
  * setting the application_registry parameter PipeLogging to an 'Y'.  This value will  *
  * be picked up by the rechecking procedures and stop sending messages to the pipe.    *
  *                                                                                     *
  * Example Call                                                                        *
  * Switch_On_App_Logging('TESTAPP','TestProc');                                                   *
  ***************************************************************************************
  */
  PROCEDURE Switch_On_App_Logging (p_Application    IN application.application_key%TYPE,
                                   p_ProcedureName  IN VARCHAR2) IS

    v_ParamKey          application_registry.parameter_key%TYPE;                                  

  BEGIN

    -- Build Parameter Key as a concatenation of Procedure Name + 'PipeLogging'
    v_ParamKey := TRIM(p_ProcedureName)||'PipeLogging';

    -- Update Application_Registry
    UPDATE application_registry ar
    SET    ar.parameter_value = 'Y'
    WHERE  ar.application_key = p_Application
    AND    ar.application_mode = 'ALL'
    AND    ar.user_key = 'ALL'
    AND    ar.parameter_key = v_ParamKey;

    COMMIT;

    EXCEPTION
    WHEN OTHERS THEN
      p_common.handle_error('p_Standard_Logging.Switch_On_App_Logging',
                            '001',
                            '900',
                            'Unable to switch On Logging for '||p_Application||'.'||p_ProcedureName);

  END Switch_On_App_Logging;



  /*
  ***************************************************************************************
  * Switch_On_Pipe_Logging                                                              *
  *                                                                                     *
  * This procedure sets the application_registry parameter to log the messages passed   *
  * into the pipe                                                                       *
  *                                                                                     *
  * Example Call                                                                        *
  * Switch_On_Pipe_Logging('TESTAPP');                                                  *
  ***************************************************************************************
  */
  PROCEDURE Switch_On_Pipe_Logging (p_Application  IN     application.application_key%TYPE) IS

    v_loc             VARCHAR2(10);

  BEGIN
    -- Ensure that the LoggingOn Parameter is set to Y as this is used to stop the pipe
    v_loc   := '001';

    UPDATE Application_Registry ar
    SET    ar.parameter_value  = 'Y'
    WHERE  ar.application_key  = p_Application
    AND    ar.application_mode = 'ALL'
    AND    ar.user_key         = 'ALL'
    AND    ar.parameter_key    = 'LoggingOn';

    COMMIT;

    EXCEPTION
    WHEN OTHERS THEN
      p_common.handle_error('p_Standard_Logging.Start_Pipe',
                            v_loc,
                            '900',
                            'Unable to update parameter LoggingOn for '||p_Application);
    END;


  /*
  ***************************************************************************************
  * Unpack_Message                                                                      *
  *                                                                                     *
  * This procedure unpacks the messages sent to the pipe and sends to console or file   *
  * depending on global variables set in procedure Set_Up_Logging                       *
  * This procedure will need to be started each morning (for each pipe) and then run    *
  * continually throughout the day.  If the pipe is stopped then the procedure will     *
  * need to be restarted.                                                               *
  *                                                                                     *
  * Example Call                                                                        *
  * Unpack_Message('TESTAPP');                                                          *
  ***************************************************************************************
  */
  PROCEDURE Unpack_Message (p_Application  IN  application.application_key%TYPE) IS

    v_text        VARCHAR(32000);
    v_oktorun     VARCHAR2(1);
    v_result      INTEGER(10);
    v_loc         VARCHAR2(10);

  BEGIN
    -- Start up the pipe ready for messages
    Start_Pipe(p_Application);

    -- See if Pipe Logging switched on (which it will be as set to 'Y' in Start_Pipe procedure
    v_oktorun := Get_Registry_Property(p_Application,'ALL', 'ALL','LoggingOn');

    -- Only keep polling as long as Logging switched on in application_registry for the pipe
    WHILE v_oktorun = 'Y' LOOP

      -- Receive all the messages sent to the pipe 
      -- This command will wait for the interval period set up for the pipe in the application_registry table
      v_result := DBMS_PIPE.receive_message (pipename => g_PipeName,
                                             timeout  => g_IntervalPeriod);

      IF v_result = 0 THEN
        -- Message received successfully so now unpack it
        DBMS_PIPE.unpack_message(v_text);

        -- Send the message to the relevant file
        utl_file.put_line(g_LoggingFile,
                          v_text);
        utl_file.fflush(g_LoggingFile);                        
      END IF;              

      -- check for value of v_finished if interval period has passed for pipe
      IF Time_Passed THEN
        -- Interval period has passed so see if logging is still necessary
        v_oktorun := Get_Registry_Property(p_Application,'ALL', 'ALL','LoggingOn');
        g_LoggingLastCheck := SYSDATE;
      END IF;  

    END LOOP;

    -- Close the file down
    utl_file.put_line(g_LoggingFile,
                   'DEBUG logging ended at: '
                   ||to_char(SYSDATE,'DD/MM/YYYY HH24:MI:SS')
                   );

    utl_file.fclose(g_LoggingFile);                  

    -- Remove the pipe
    v_loc := '001';
    v_result := DBMS_PIPE.remove_pipe(pipename => g_PipeName);    
    IF v_result != 0 THEN
      p_common.handle_error('p_Standard_Logging.Start_Pipe',
                            v_loc,
                            SQLCODE,
                            'Unable to stop pipe for '||p_Application);
    END IF;                                                                            

  END Unpack_Message;  

BEGIN 
  -- Initialization
  NULL;
END p_Standard_Logging;</pre>
</div>
</div>
</div>
</body>
</html>
